# Работа с ветками на практике  

__*Тема 2/5 (Работа с ветками на практике) - Урок 1/5*__  

## Что такое fast-forward  

В этой теме расскажем о подходах к работе с ветками в команде. А именно: в какой момент создаются ветки, когда они сливаются друг с другом, какие коммиты и в какую ветку попадают.  

Чтобы разобрать плюсы и минусы реально используемых подходов, сначала объясним, чем плох простой и очевидный подход «все дружно „пушим“ в `main` по очереди!». Для этого понадобится рассмотреть понятие __fast-forward__ (англ. «перемотка вперёд») и его связь с `git push`. Начнём с __fast-forward__: что это такое и как его распознать.  

## Состояние *fast-forward*  

Две ветки находятся в состоянии __fast-forward__, если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая. Это утверждение можно сформулировать иначе:  

- при слиянии этих двух веток никак не возможен конфликт;  
- истории этих двух веток не «разошлись»;  
- одна ветка является продолжением другой.  

Хотя все эти условия звучат по-разному, они значат одно и то же.  

Разберём на примере. Есть две ветки: `main` и `add-docs` (англ. «добавить документацию»). В ветке `main` четыре коммита, от неё создали ветку `add-docs` и добавили в неё ещё два коммита.  

```text
$ git branch
* add-docs
  main

$ git log --oneline
e08fa2a (HEAD -> add-docs) New docs 2
fd588b2 New docs 1
997d9ce (main) Commit 4
0313e8e Commit 3
5848aba Commit 2
04923d7 Commit 1 
```

Схематически можно изобразить ветки main и add-docs так.
![branches - Pic 15](pics/branches_pic15.jpg)

Ветка `add-docs` «обгоняет» ветку `main` на два коммита: __N1__ и __N2__ (в нашем примере с кодом они называются `New docs 1` и `New docs 2`).  

Допустим, мы хотим влить ветку `add-docs` в `main`. При этом все коммиты из `add-docs` можно просто «положить» в `main`, и они выстроятся за уже существующими.  

Результат слияния будет выглядеть так.  

```text
$ git checkout main
$ git merge add-docs
Updating 997d9ce..e08fa2a
Fast-forward
 docs.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 docs.txt

$ git log --oneline
e08fa2a (HEAD -> main, add-docs) New docs 2
fd588b2 New docs 1
997d9ce Commit 4
0313e8e Commit 3
5848aba Commit 2
04923d7 Commit 1 
```

Обратите внимание на два момента:  

- При слиянии веток Git выводит строку `Fast-forward`.  
- В истории коммитов `HEAD` указывает одновременно и на `main`, и на `add-docs`. После такого слияния эти ветки одинаковые: в них одни и те же коммиты.  

Схематически результат слияния веток выглядит так.  
![branches - Pic 161](pics/branches_pic16.jpg)

Git просто добавил коммиты из `add-docs` в ветку `main`, или перемотал `main` вперёд до состояния `add-docs`. Отсюда и название «перемотка».  

## Можно ли отключить *fast-forward*  

__Fast-forward__ слияние веток можно отключить флагом `--no-ff`. Например: `git merge --no-ff add-docs`. Также его можно отключить «навсегда» (до тех пор, пока вы не вернёте настройку «как было») с помощью настройки `merge.ff`: `git config [--global] merge.ff false`.  

Если отключить слияние в режиме `fast-forward`, вместо «перемотки» ветки Git создаст в ней __коммит слияния__ (англ. *merge commit*) — в обиходе его называют __merge-коммит__ или __мёрж-коммит__. В этом случае результат «вливания» ветки `add-docs` в `main` выглядел бы так.  

```text
# находимся в ветке main
# --no-edit отключает ввод сообщения для merge-коммита
# --no-ff отключает fast-forward слияние веток
$ git merge --no-edit --no-ff add-docs
Merge made by the 'ort' strategy.
 docs.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 docs.txt

# с флагом --graph
# Git нарисует ветки с помощью «палочек» и «звёздочек»
# получившийся коммит слияния: 6814789
$ git log --graph --oneline
*   6814789 (HEAD -> main) Merge branch 'add-docs'
|\
| * e08fa2a (add-docs) New docs 2
| * fd588b2 New docs 1
|/
* 997d9ce Commit 4
* 0313e8e Commit 3
* 5848aba Commit 2
* 04923d7 Commit 1 
```

На схеме результат слияния будет таким.
![branches - Pic 17](pics/branches_pic17.jpg)

> 💡 Зачем отключать __fast-forward__?  
>Многие проекты отключают *fast-forward* слияние веток, потому что при нём теряется часть информации. Результат выглядит так, как будто в `main` «просто появились» новые коммиты. Если не знать о ветке `add-docs`, то можно подумать, что такой ветки и не было.  
> Полноценный коммит слияния сохраняет всю информацию: в нём будет указано, какая именно ветка вливалась в `main`.  

Итак:  

- Если истории двух веток не «разошлись» и их коммиты выстраиваются в одну цепочку, эти ветки можно объединить в режиме __fast-forward__.  
- Режим __fast-forward__ можно отключить с помощью флага `--no-ff`.  

---

__*Тема 2/5 (Работа с ветками на практике) - Урок 1/5*__  

## *Non-fast-forward*  

В прошлом уроке вы поближе познакомились с состоянием *fast-forward*. Теперь покажем, что происходит при объединении двух веток, коммиты которых нельзя выстроить в одну цепочку.  

## Состояние *non-fast-forward*  

Вернёмся к примеру с ветками `main` и `add-docs` и представим такую ситуацию: истории двух веток «разошлись». Это значит, что их коммиты уже нельзя выстроить в одну линию.  

Например, после «отделения» `add-docs` в ветку `main` добавили новый коммит `Commit 5`.  

```text
# команде git log можно указать несколько веток,
# и тогда она выведет их все
$ git log --graph --oneline main add-docs
* 15d3f04 (HEAD -> main) Commit 5
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1 
```

На схеме это будет выглядеть так.  
![branches - Pic 18](pics/branches_pic18.jpg)

Теперь просто «положить» все коммиты из `add-docs` в `main` не получится. Например, коммит __C5__ из `main` может конфликтовать с каким-нибудь коммитом из ветки `add-docs` (__N1__ или с __N2__; на схеме ниже мы выбрали __N1__ в качестве примера). То есть содержать изменения в тех же файлах (и в тех же строках), что и коммит __C5__.  
![branches - Pic 19](pics/branches_pic19.jpg)

> ⚠️ Когда Git проверяет ветки на состояние *fast-forward*, он не «заглядывает» в файлы и не пытается угадать, будет ли конфликт на самом деле. Для Git важно только, что конфликт теоретически возможен (или, наоборот, никак не возможен).  

При слиянии __не-fast-forward__ веток Git создаёт __коммит слияния__.  

```text
# находимся в ветке main
# --no-edit избавляет от необходимости
# вводить сообщение для merge-коммита
$ git merge --no-edit add-docs
Merge made by the 'ort' strategy.
 docs.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 docs.txt

# коммит слияния: 34f5f8f
$ git log --graph --oneline
*   34f5f8f (HEAD -> main) Merge branch 'add-docs'
|\
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
* | 15d3f04 Commit 5
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1 
```

На схеме это будет выглядеть так.  
![branches - Pic 20](pics/branches_pic20.jpg)

Если конфликтов при слиянии нет, команда `git merge` отработает почти автоматически — только предложит вам ввести сообщение для нового __коммита слияния__.  

> 💡 Чаще всего сообщения к коммитам слияния не редактируют и оставляют «как предложил Git». Для таких случаев удобен флаг `--no-edit`: `git merge --no-edit %another_branch%`.  

Если конфликты всё-таки есть, Git сначала попытается разрешить их автоматически. Если не получится, Git предложит вам разрешить их вручную. Как разрешать конфликты и какие для этого есть инструменты, мы покажем в следующих уроках модуля.

*Коротко подытожим*:  

- Если истории двух веток всё же «разошлись», при слиянии веток Git создаст коммит слияния.  
- При объединении веток в состоянии __не-fast-forward__ возможны (но не обязательны) конфликты. Если конфликты всё же возникли, Git попытается разрешить их самостоятельно или попросит вас сделать это вручную.  

---

__*Тема 2/5 (Работа с ветками на практике) - Урок 3/5*__  

## Напомним про `git push`  

Коротко напомним, что делает команда `git push`: она «толкает» коммиты из локальной ветки в её удалённую копию.  

Допустим, вы находитесь в ветке `main` в локальном репозитории и выполняете `git push`. В результате __все новые коммиты из локальной__ ветки `main` попадут в ветку `main` в __репозитории на GitHub__. После этого локальная и удалённая ветки будут содержать __одни и те же__ коммиты.  

Хотя `git push` не выполняет слияния веток, для этой команды тоже важно состояние __fast-forward__, но специфическое: между локальной веткой (откуда берутся коммиты для `push`) и удалённой (куда эти коммиты попадут).  

> ⚠️ Обычно локальная и удалённая ветки называются одинаково. Чтобы их различать, мы будем называть локальные ветки просто именем (например, `main`), а удалённые — с суффиксом `@origin` (например, `main@origin`).  
>
>Ветка `main` находится на локальном компьютере, а `main@origin` — в репозитории на GitHub.  

Если `main` и `main@origin` находятся между собой в состоянии `fast-forward` (`main@origin` можно просто «перемотать» до того же состояния, что и `main`), то `git push` так и сделает. В итоге локальная и удалённая ветки будут содержать одинаковый набор коммитов.  
![branches - Pic 21](pics/branches_pic21.jpg)

Ветки `main` и `main@origin` можно нарисовать на одной схеме, потому что локальные коммиты идентичны удалённым. В таком случае схема будет похожа на схемы из предыдущих уроков.  
![branches - Pic 22](pics/branches_pic22.jpg)

## `git push` и *не-fast-forward*  

Представим, что ветки `main` и `main@origin` находятся в таком состоянии: в ветке `main@origin` есть коммиты __C1__, __C2__ и D, а в `main` — __C1__, __C2__, __C3__, __C4__.  
![alt text](pics/branches_pic23.jpg)

Ветки `main` и `main@origin` «разошлись», то есть находятся в состоянии __не-fast-forward__. Если теперь попытаться выполнить команду `git push`, она выведет следующую ошибку.  

```text
# текущая ветка — main
$ git push
To github.com:username/repository.git
 ! [rejected]        main -> main (non-fast-forward)
error: failed to push some refs to 'github.com:username/repository.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details. 
```

Обратите внимание на надписи `rejected` (англ. «запрос отклонён») и `non-fast-forward` — Git подсказывает, что именно пошло не так.  

## Пара слов о *rebase*  

В Git можно решить проблему «разошедшихся» веток с помощью операции __rebase__ (англ. «перебазирование»). Эта операция позволяет изменить точку (коммит), от которой отделилась ветка. Результат перебазирования ветки `main` c коммита __C2__ на коммит __D__ можно увидеть на схеме.  
![branches - Pic 24](pics/branches_pic24.jpg)

После такого перебазирования ветки будут в состоянии `fast-forward`, и `git push` сработает без ошибок. Однако у такого шага могут быть последствия. Например:  

- могут возникать конфликты между изменениями, как при слиянии веток;  
- если действовать неаккуратно, можно __«сломать»__ репозиторий.  

И всё же это мощный инструмент, который поможет во многих сложных ситуациях. Подробнее об операции перебазирования мы ещё расскажем в курсе.  

## Пара слов о `git push --force`  

Есть и другой способ справиться с ошибкой `rejected: non-fast-forward` — это форсированный пуш. Чтобы его выполнить, используют флаг `--force` (англ. «сила», «заставить»).  

Вернёмся к примеру с «разошедшимися» ветками `main` и `main@origin`.  
![branches - Pic 25](pics/branches_pic25.jpg)

В этом случае команда `git push --force` просто «выкинет» (удалит) коммит __D__ и запишет в `main@origin` коммиты из `main`. Вот что получится.  
![branches - Pic 26](pics/branches_pic26.jpg)

Коммит __D__ просто исчез!  

> 💡 В очень редких случаях это уместная команда. Например, если кто-то нечаянно «сломал» ветку `main@origin`, можно найти копию репозитория, в которой ветка `main` не «сломана», и использовать `git push --force` для восстановления ветки в `origin`.  

---

__*Тема 2/5 (Работа с ветками на практике) - Урок 4/5*__  

## Почему бы не «пушить» всё в `main`  

В самом простом случае человек трудится над проектом в одиночку. Тогда ему, скорее всего, не понадобятся дополнительные ветки: он может «коммитить» и «пушить» всё в `main` и не усложнять.  
Но если над проектом работает команда из нескольких человек, то подход «просто „запушить“ всё в `main`» перестаёт быть удобным. И вот почему:  

- Новым сотрудникам нужно время, чтобы влиться в рабочий процесс. Если сотрудник недавно присоединился к проекту, он может сделать что-нибудь не так, как принято, просто потому, что ещё не освоился. Если дать ему возможность выполнять `git push` прямо в `main`, он может «запушить» что-то не то.  
- Команда `git push` ожидает, что обновление ветки будет происходить в режиме __fast-forward__. Добиться этого при активной работе нескольких человек с одной веткой сложно. Разберём подробнее, почему так происходит.  

## Связь `git push`, *fast-forward* и «все „пушат” в main»  

В прошлом уроке мы рассказали вот о чём: команда `git push` ожидает, что локальная ветка и её удалённая версия не «разошлись», то есть одна может просто «догнать» другую без конфликтов.  
Если несколько человек будут «пушить» коммиты прямо в `main`, локальная ветка `main` и ветка `main` на GitHub (`main@origin`) будут постоянно «расходиться» у других участников команды.  

## Пример  

Представим двух разработчиков: Пашу и Лёшу. Оба договорились использовать только ветку `main` и «пушить» коммиты напрямую в неё.  
Есть три ветки `main`: одна на GitHub (общая), одна в локальном репозитории Паши и одна в локальном репозитории Лёши.  

Опишем один день из жизни этих веток:

Утром всё было хорошо и все ветки были равны — в каждой по три коммита:  __C1__, __C2__ и __C3__.  
![branches - Pic 27](pics/branches_pic27.jpg)

Позже и Паша, и Лёша сделали по коммиту локально: Паша сделал коммит __P__, Лёша — коммит __L__.  

__Обратите внимание__: `main` и Паши, и Лёши находятся в состоянии __fast-forward__ относительно `main` на GitHub. Но между собой ветки героев «разошлись».  

Паша встаёт раньше Лёши и работает быстрее, так что он первым «запушил» свой коммит на GitHub. После этого ветки стали такими.  
![branches - Pic 28](pics/branches_pic28.jpg)

В этот момент ветка `main` у Лёши «разошлась» с `main` на GitHub — они стали __не-fast-forward__ между собой. В прошлом уроке мы упоминали, как можно разрешить эту проблему. У Лёши есть два пути: __форсированный пуш__ или перебазирование своей ветки так, чтобы она «росла» от коммита __P__, а не от __C3__.  

__Форсированный пуш__ удалит работу Паши — следовательно, такой способ не подходит. Скорее всего, Лёша выберет операцию __*rebase*__ и только после этого «запушит» свои изменения.  
Операция __*rebase*__ может спасти проект из двух разработчиков, которые нечасто «коммитят» изменения. Но она не подойдёт, например, для команды из __10__ человек: им придётся тратить больше времени на перебазирование веток, а не на полезные задачи.  

> 💡 В большинстве систем управления репозиториями (GitHub, GitLab, Bitbucket и подобных) есть специальная настройка «запретить push в main». Чаще всего она включена, и прямые `git push` в `main` запрещены.  

---

__*Тема 2/5 (Работа с ветками на практике) - Урок 5/5*__  

## Модели веток. Простая *feature branch* модель  

В предыдущих уроках мы объяснили, что не так с самым простым подходом с одной общей веткой `main`. Теперь разберём популярные подходы, которые отвечают задачам командной разработки и обычно не вызывают проблем.  

Начнём с определения. __Подходы к работе с ветками__ — это правила, которые описывают, когда и для чего создаются ветки, какие в них коммиты и в какой момент происходит слияние веток.  
Допустим, вы разработчик и приходите в команду, где уже используют один из подходов. Чем быстрее вы поймёте, по каким правилам действуют ваши коллеги, тем проще вам будет освоиться на новом месте и влиться в процесс.  

> ⚠️ Подходы, о которых мы будем говорить, придуманы для репозиториев с исходным кодом программ. Если вы планируете использовать Git для других типов проектов, эти модели могут как подойти, так и оказаться неэффективными.  

## Подходы  

Рассмотрим три самых популярных подхода — их также принято называть __workflow__ (англ. «рабочий процесс») или сокращённо: __flow__.  

- __Feature branch workflow__ — простой и самый популярный вариант. Если коротко, в нём для каждого нового изменения создаётся новая ветка, которая позже вливается в `main` с помощью `git merge`.  
- __Git flow__ — более сложный вариант. Подход похож на __feature branch workflow__, но в нём создаётся больше веток, а изменения (коммиты) делят на разные типы: исправление, новая функциональность и так далее. Разные типы коммитов попадают в разные ветки.  
- __Trunk-based__ — популярный в больших компаниях (таких как Яндекс, Google и прочих) подход, который обещает бо́льшую скорость работы в крупных командах.  
Этот подход тоже похож на __feature branch workflow__. Главное отличие в том, что участники проекта вливают (`merge`) свой код в основную ветку максимально часто. Например, каждый день.  

Пока сосредоточимся на более простой модели — __feature branch workflow__. Важно понимать, что во всех подходах есть много общего. Если вы поймёте, как работает один из них, освоить другие будет несложно.  

## *Feature branch workflow*  

Основная идея модели __feature branch workflow__ (от англ. *feature* — «особенность», «деталь») в том, что работа над любой новой функциональностью или исправлением ведётся в отдельной ветке.  
Допустим, у вас есть задача добавить большую оранжевую кнопку. Тогда вам нужно будет создать ветку `feature/add-big-orange-button`. Ветка может называться и по-другому — главное, чтобы это была отдельная ветка под конкретную задачу. Все коммиты, которые относятся к созданию кнопки, попадают в эту ветку. Когда кнопка полностью готова, ветка `feature/add-big-orange-button` вливается (`merge`) в ветку `main`.  
![branches - Piс 29](pics/branches_pic29.jpg)

Подход __feature branch workflow__ позволяет разработчикам трудиться над новыми функциональностями (или фичами) независимо друг от друга и не затрагивать основную ветку кода в процессе. Так как каждый работает над своей веткой самостоятельно, не возникает проблемы «расходящейся» общей ветки, которую мы описали в прошлом уроке.  

При таком подходе все коммиты в ветке `main` — это коммиты слияния (__feature-ветки__ вливаются в `main`).  

Если аккуратно следовать подходу __feature branch workflow__, то:  

- Не будет проблемы «расхождения» веток, ведь новые изменения попадают в `main` через `git merge`, а не через `git push`.   - Команду `merge` «разошедшиеся» ветки не смущают, ведь для них она и придумана.  
- В ветке `main` всегда рабочая версия проекта. Все «полуфабрикаты» и недоделанные функциональности находятся в __feature-ветках__, пока не будут готовы попасть в `main`.  

## О *feature branch workflow* коротко  

__Основные правила:__

- новая функциональность или исправление — новая ветка;  
- когда код в __feature-ветке__ готов, он вливается в `main`;  
- в `main` всегда рабочая версия без «недоделок».  

__Преимущества:__  

- простая модель;  
- позволяет работать с Git в команде без лишних технических сложностей.  

> 💡 __Шаблон, а не алгоритм__
>Подход *feature branch workflow* — это только «заготовка», которой необязательно следовать строго. Каждая команда подстраивает процесс под себя: например, что-то добавляет в модель или убирает из неё.  
>
>Так что описать все существующие возможности подхода было бы сложно. Важно запомнить его ключевую особенность: одна ветка main и много *feature-веток*, которые вливают в основную.  

__Итак__:

- Разные компании и команды используют разные модели работы с Git. Эти модели описывают структуру веток в проекте, а также правила создания и слияния коммитов в них.  
- Один из самых простых и популярных подходов — __feature branch workflow__. Он предполагает, что работа над функциональностью ведётся в отдельной __feature-ветке__. Когда всё готово, эта ветка вливается в основную.  
- Подход __feature branch workflow__ — лишь шаблон, по которому можно действовать. Многие компании и команды меняют его под свои нужды, но неизменно одно: __хочешь сделать новую функциональность или исправить баг — создай новую ветку__!  

---
